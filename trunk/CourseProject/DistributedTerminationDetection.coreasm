// CMPT 475 Course Project (Spring, '12)
// Aparna Agarwal, 301087691
// Cley Tang, 301116141 
// James Wall, 301089955

CoreASM DistributedTerminationDetection

use StandardPlugins
use TimePlugin
use MathPlugin

enum Colour = {black, white}
enum Token = {noToken, blackToken, whiteToken}

enum Machine = {machine0, machine1, machine2, machine3, machine4, machine5, machine6, machine7, machine8}
enum Computation = {comp1, comp2, comp3}


function colour : Machine * Computation -> Colour
function token : Machine * Computation -> Token
function nextMachine: Machine -> Machine

function isActive : Machine * Computation -> boolean
function blackTokenEvent : Machine * Computation -> boolean
function whiteTokenEvent : Machine * Computation -> boolean
function sendMessageEvent : Machine * Computation -> boolean

function terminated : Computation -> boolean

universe Agents = {supervisorMachine, regularMachine, observer}

init InitRule

rule InitRule = par	
	startTime := now
	//terminated(comp1) := false
	//terminated(comp2) := true
	//terminated(comp3) := true
	forall c in Computation do
	par
		terminated(c) := false
		forall m in Machine do
		par
			if m = machine0 then seqblock
				InitializeMachine(m, c)
				token(m, c) := blackToken
				AssignNextMachine(m)
				isActive(m, c) := false
			endseqblock
			else par			
				InitializeMachine(m, c)
				AssignNextMachine(m)
				isActive(m, c) := true
			endpar	
		endpar
	endpar
		
	program(supervisorMachine) := @SupervisorMachineProgram
	program(regularMachine) := @RegularMachineProgram
	program(observer) := @ObserverProgram	
	program(self) := undef
endpar


rule ObserverProgram = par
	forall c in Computation with (not terminated(c)) do seqblock		
		print "Time: " + ((now - startTime) / 1000) + " seconds:"	
		choose m in Machine with token(m, c) != noToken do seqblock			
			print "Computation " + c + ":"
			print "Machine " + m + " holding " + token(m, c)
			print "Machine " + m + ":- colour: " + colour(m, c) + "  , Active: " + isActive(m, c)
			print ""
		endseqblock
	endseqblock
endpar



rule AssignNextMachine(m) = par
	if m = machine1 then
		nextMachine(m) := machine0
	if m = machine2 then
		nextMachine(m) := machine1
	if m = machine3 then
		nextMachine(m) := machine2
	if m = machine4 then
		nextMachine(m) := machine3
	if m = machine5 then
		nextMachine(m) := machine4
	if m = machine6 then
		nextMachine(m) := machine5
	if m = machine7 then
		nextMachine(m) := machine6
	if m = machine8 then
		nextMachine(m) := machine7
		
	if m = machine0 then
		nextMachine(m) := machine8	
endpar


rule ForwardToken(oldM, t, m, c) = seqblock
	token(m, c) := t
	//print "forwarded " +t +" to " + m 
	if t = blackToken or colour(m, c) = black then
		blackTokenEvent(m, c) := true
	else
		whiteTokenEvent(m, c) := true
	
	//InitializeMachine(oldM)
	ObserverProgram
endseqblock


rule ReactOnEvents(m, c) = par
	if blackTokenEvent(m, c) then
		token(m, c) := blackToken
	if whiteTokenEvent(m, c) then
		token(m, c) := whiteToken
	if sendMessageEvent(m, c) then
		colour(m, c) := black
endpar


rule InitializeMachine(m, c) = seqblock
	token(m, c) := noToken
	colour(m, c) := white
	blackTokenEvent(m, c) := false
	whiteTokenEvent(m, c) := false
	sendMessageEvent(m, c) := false
endseqblock


rule RegularMachineProgram = 
	forall c in Computation with (not terminated(c)) do
	par	
		forall m in Machine with m != machine0 do
		par
			seq
				ReactOnEvents(m, c)
			next
				if (not isActive(m, c)) and token(m, c) != noToken then par
					InitializeMachine(m, c)
					if colour(m, c) = black then
						ForwardToken(m, blackToken, nextMachine(m), c)
					else if colour(m, c) = white then
						ForwardToken(m, token(m, c), nextMachine(m), c)
				endpar
				
				if isActive(m, c) then par
					rand := random
					if rand < 0.25 then
						sendMessageEvent(m, c) := true
					if rand > 0.75 then
						isActive(m, c) := false
				endpar	
			
		endpar
	endpar	



rule SupervisorMachineProgram = seqblock
	forall c in Computation with (not terminated(c)) do
	par
		choose m in Machine with m = machine0 do
		par
			seq
				ReactOnEvents(m, c)
			next
				if (not isActive(m, c)) and token(m, c) != noToken then par
					if colour(m, c) = white and token(m, c) = whiteToken then seqblock
						terminated(c) := true
						print "Computation " + c + " terminated"
						//if not(choose c in Computation with (not terminated(c))) then par
						//	ReportGlobalTermination
						//endpar
					endseqblock
					else par
						InitializeMachine(m, c)
						ForwardToken(m, whiteToken, nextMachine(m), c)
					endpar
				endpar
		endpar
	endpar
endseqblock


rule ReportGlobalTermination = seqblock
	program(observer) := undef
	program(supervisorMachine) := undef
	program(regularMachine) := undef
	program(self) := undef	
	print "Global Termination"
endseqblock
