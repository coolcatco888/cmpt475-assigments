// CMPT 475 Course Project (Spring, '12)
// Aparna Agarwal, 301087691
// Cley Tang, 301116141 
// James Wall, 301089955



/*

- isActive - initalize?

nextMachine??

output??

more than one computations?
*/

CoreASM DistributedTerminationDetection

use StandardPlugins
use TimePlugin
use MathPlugin

enum Colour = {black, white}
enum Token = {noToken, blackToken, whiteToken}

enum Machine = {machine0, machine1, machine2, machine3, machine4, machine5, machine6, machine7, machine8}
enum Computation = {comp1, comp2, comp3}


function colour : Machine -> Colour
function token : Machine -> Token
function nextMachine: Machine -> Machine

function isActive : Machine -> boolean
function blackTokenEvent : Machine -> boolean
function whiteTokenEvent : Machine -> boolean
function sendMessageEvent : Machine -> boolean

universe Agents = {supervisorMachine, regularMachine, observer}

init InitRule

rule InitRule = par	
	startTime := now
	forall m in Machine do
	par
		if m = machine0 then par
			colour(m) := white
			//InitializeMachine(m)
			token(m) := blackToken
			AssignNextMachine(m)
		endpar
		else par			
			InitializeMachine(m)
			//token(m) := noToken
			AssignNextMachine(m)
		endpar
				
		if m = machine2 or m = machine4 or m = machine6 or m = machine7 then
			isActive(m) := true
		else
			isActive(m) := false
		
		colour(m) := white		
	endpar
	program(observer) := @ObserverProgram
	program(supervisorMachine) := @SupervisorMachineProgram
	program(regularMachine) := @RegularMachineProgram	
	program(self) := undef
endpar


rule ObserverProgram = par
	forall m in Machine with token(m) != noToken do seqblock
		print "Time: " + ((now - startTime) / 1000) + " seconds"
		print "Machine " + m + " holding " + token(m)
		print "Machine" + m + " is of colour " + colour(m)
		print ""
	endseqblock
endpar



rule AssignNextMachine(m) = par
	if m = machine0 then
		nextMachine(m) := machine8
	if m = machine1 then
		nextMachine(m) := machine0
	if m = machine2 then
		nextMachine(m) := machine1
	if m = machine3 then
		nextMachine(m) := machine2
	if m = machine4 then
		nextMachine(m) := machine3
	if m = machine5 then
		nextMachine(m) := machine4
	if m = machine6 then
		nextMachine(m) := machine5
	if m = machine7 then
		nextMachine(m) := machine6
	if m = machine8 then
		nextMachine(m) := machine7
	
endpar


rule ForwardToken(t, m) = seqblock
	token(m) := t
	//print "forwarded " +t +" to " + m 
	if t = blackToken or colour(m) = black then
		blackTokenEvent(m) := true
	else
		whiteTokenEvent(m) := true
endseqblock


rule ReactOnEvents(m) = seqblock
	if blackTokenEvent(m) then
		token(m) := blackToken
	if whiteTokenEvent(m) then
		token(m) := whiteToken
	if sendMessageEvent(m) then
		colour(m) := black
endseqblock


rule InitializeMachine(m) = seqblock
	token(m) := noToken
	colour(m) := white
	blackTokenEvent(m) := false
	whiteTokenEvent(m) := false
	sendMessageEvent(m) := false
endseqblock


rule RegularMachineProgram = 
	forall m in Machine with m != machine0 do
	par
		seq
			ReactOnEvents(m)	
			//print m + "  regular  " +nextMachine(m) + "   " +token(m)
		next
			if (not isActive(m)) and token(m) != noToken then par
				InitializeMachine(m)	// after if-else statement???
				//print m + "  regular  " +nextMachine(m) + token(m)
				if colour(m) = black then
					ForwardToken(blackToken, nextMachine(m))
				else if colour(m) = white then
					ForwardToken(token(m), nextMachine(m))
				//InitializeMachine(m)
			endpar
			
			if isActive(m) then par
				rand := random
				if rand < 0.25 then
					sendMessageEvent(m) := true
				if rand > 0.5 then
					isActive(m) := false
			endpar	
		
	endpar	



rule SupervisorMachineProgram = seqblock
	choose m in Machine with m = machine0 do
	par
		seq
			ReactOnEvents(m)
		//print m + "  super  " +nextMachine(m) + "   " +token(m)
		next
			if (not isActive(m)) and token(m) != noToken then par
				if colour(m) = white and token(m) = whiteToken then
					print "Termination"
				else par
					InitializeMachine(m)
					ForwardToken(whiteToken, nextMachine(m))
					//InitializeMachine(m)
				endpar
			endpar
	endpar
endseqblock
